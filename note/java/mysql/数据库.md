### 存储引擎
    1. 概念
        数据库存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用数据引擎
        进行创建，查询，更新和删除数据，不同的存储引擎提供不同的存储机制，
        索引技巧，锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能
        现在许多不同的数据库管理系统都支持多种不同的数据引擎
            主要有：
                1. MyISAM
                2. InnoDB
                3. Memory
                4. Archive
                5. Federated
                
### InnoDB(B+树)
    InnoDB底层存储结构为B+树，B+树的每个叶子节点对应innodb的一个page，page大小
    是固定的，一般设为16k，其中非叶子几点只有键值，叶子节点包含完整数据
    使用场景：
        1. 经常更新的表，适合处理多重并发的更新请求
        2. 支持事务
        3. 可以从灾难中恢复(通过bin-log日志)
        4. 外键约束，只有他支持外键
        5. 支持自动增加列属性auto_increment
        
        
### MyISAM
    Mysql 5.1版本前的默认引擎
    不支持数据库事务
    不支持行级锁和外键
    因此当insert(插入)或update(更新)数据时即写操作需要锁定整个表
    效率会低一些
    MyISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源，
    在设计之处就预想数据组织成有固定长度的记录，
    按顺序存储的
    
### 索引
    索引是帮助Mysql搞笑获取数据的数据结构，常见的查询算法
        顺序查找
        二分查找
        二叉树查找
        哈希散列法
        分块查找
        平衡多路搜索树
        B树
        
### 索引原则
    1. 选择唯一性索引
    2. 为经常需要排序，分组和联合操作的字段建立索引
    3. 为常作为查询条件的字段建立索引
    4. 限制索引的数目
        越多的索引，会使更新表变得很浪费时间
    5. 尽量使用数据量少的索引
        如果索引的值很长，那么查询的速度会受到影响
    6. 尽量使用前缀来索引
        如果索引字段的值很长，最好使用值的前缀来索引
    7. 删除不再使用或者很少使用的索引
    8. 最左前缀匹配原则
    9. 尽量选择分区度搞的列作为索引
        分区度的共识是表示字段不重复的比例
    10. 索引列不能参与计算，保持列"干净"，带函数的查询不参与索引
    11. 尽量的扩展索引，不要新建索引
    
### 数据库的三范式
    范式是具有最小冗余的表结构
     
    第一范式(列都是不可再分的)
        保证每列的原子性    
    
    第二范式(每个表只描述一件事)
        首先满足第一范式，并且表中非主键列不存在对主键的部分依赖，
        第二范式要求每个表只描述一件事
        
    第三范式(不存在对非主键列的传递依赖)
        第三范式是，满足第二范式，并且表中的列不存在对非主键列的传递依赖
        除了主键订单编号，顾客姓名依赖于非主键顾客编号
        
### 数据库事务
    事务是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起
    向系统提交，要么都执行，要么都不执行，事务是一个不可分割的工作逻辑单元
    
    事务必须具备以下四个属性，简称ACID属性：
        原子性(Actomicity)：
            事务是一个完整的操作，事务的各步操作是不可分的，要么都执行，
            要么都不执行
            
        一致性(Consistency)：
            当事务完成时，数据必须处于一致状态
            
        隔离性(Isolation)：
            对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的
            它不应以任何方式依赖于或影响其他事务
            
        永久性(Duability)：
            事务完成后，它对数据库的修改被永久保持，事务日志能后保证事务的永久性
            
                    
###  数据并发策略
    并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳
    
    1. 乐观锁：
        乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自
        己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间
        戳就是不加锁，通过时间戳来控制并发出现的问题。
        
    2. 悲观锁：
        悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加
        锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数
        据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允
        许其他用户访问那部分数据。
    
    3. 时间戳：
        时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字
        段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数
        据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁
        机制，但是这种方法可以大大提高数据库处理的并发量，
        
    以上悲观锁所说的加"锁"，其实分为几种锁，分别是：排他锁(写锁)和共享锁(读锁)
    
### 数据库锁
    行级锁是一种排他锁，防止其他事务修改此行
    1. insert，update，delete，select for update
    2. select ... for update 语句允许用户一次锁定多条记录进行更新
    3. 使用commit或rollback语句释放锁
    
    表级锁
        表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分
        Mysql引擎支持，最长用的MyISAM与InnoDB都支持表级锁，表级锁分为
        表共享读锁(共享锁)与表独占写锁(排他锁)
        
    页级锁
        页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级
        冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁
        
    基于Redis的分布式锁
        1. 获取锁的时候，使用setnx(SETNX key val：当且仅当key不存在时，set一个key
        为val的字符串，返回1；若key存在，则什么都不做，返回0)加锁，锁的是valye值为一个
        随机生成的uuid，在释放锁的时候进行判断，并使用expire命令为锁添加一个超时时间，
        超过该时间则自动释放锁
        
        2. 获取锁的时候调用setnx，如果返回0，则该锁正在被别人使用，返回1则成功获取锁，
        还设置了一个获取的超时时间，如果超过这个时间则放弃获取锁
        
        3. 释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放
        

### 分区分表
    分库分表有垂直切分和水平切分两种
        1. 垂直切分(按照功能模块)
        2. 水平切分(按照规则划分存储)
        
        
        
        
