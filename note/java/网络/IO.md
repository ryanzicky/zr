### Java IO/NIO
    1. 阻塞IO模型
        当用户发出IO请求之后，内核回去查看数据是否就绪，如果没有就绪就会等待数据就绪
        而用户线程就会处于阻塞状态，用户线程交出CPU，当数据就绪之后，内核会将数据拷贝
        到用户线程，并返回结果给用户线程，用户线程才会解除blovk状态，典型的阻塞IO模型
        的例子为：
            data = socker.read()
            如果没有数据，就会一直阻塞在read方法
            
    2. 非阻塞IO模型
        在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就是说
        非阻塞IO不会交出CPU，而会一直占用CPU，典型的非阻塞IO模型如下：
            while(true) {
                data = socket.read();
                if (data != error) {
                    // 处理数据
                    breal;
                }
            }
        在while循环中需要不断地去询问内核数据是够就绪，这样会导致CPU占用率非常高
    
    3. 多路复用IO模型
        Java NIO实际上就是多路复用IO
        在多路复用IO模型中，会有一个线程不断地去询问多个socket状态，只有当socket
        真正有读写事件时，才真正调用实际的IO读写操作，因为在多路复用IO模型中，只需要
        使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护
        这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它
        大大介绍了资源占用。在Java NIO中，是通过 selector.select(); 去查询每个通道是否
        有达到事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞，
        多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件
        发生才会占用资源来进行实际的读写操作，因此，多路复用IO比较是个连接数比较多
        的情况
        
        非阻塞IO模型：
            不断询问socket状态是通过用户线程去进行的
        多路复用IO：
            轮询每个socket状态是内核在进行的，这个效率要比用户线程高得多
            
            通过轮询的方式来监测是否有事件到达，并且对到达的事件逐一进行相应
            一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且
            会影响新的事件轮询
            
    4. 信号驱动IO模型
        在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函
        数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到
        信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。
        
     5. 异步 IO 模型
        异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就
        可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，
        它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内
        核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程
        发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何
        进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接
        去使用数据了。
        
        也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完
        成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的
        读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据
        已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号
        表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。
        
### NIO
    Channel：
        通道
        Channel和IO的Stream是差不多一个等级的，只不过Stream是单向的，譬如：
        InputStream，OutputStream，而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作
        
        主要实现有：
            FileChannel
            DatagramChannel
            SocketChannel
            ServerSocketChannel
        
    Buffer：
        缓冲区
        
        实际上是一个容器，是一个连续数组
        Channel提供从文件，网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer
        
        客户端发送数据时，必须先将数据存入Buffer中，然后将Buffer中的内容写入通道，服务端这边接收数据必须通过
        Channel将数据读入到Buffer中，然后再从Buffer中取出数据来处理
        
        Buffer是一个顶层父类，它是一个抽象类，常用的Buffer的子类有：
            BYteBuffer
            IntBuffer
            LongBuffer
            DoubleBuffer
            FloatBuffer
            ShortBuffer
        
    Selector：
        选择区
        
        Selector类是NIO的核心类，Selector能够检测多个注册的通道上是否有事件发生，如果有事件发生，
        便获取事件然后针对每个事件进行相应的响应处理
        
    传统IO基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据总是从通道读取到缓冲区中，
    或者从缓冲区写入到通道中，Selector用于监听多个通道事件(比如：连接打开，数据到达)
    因此，单个线程可以监听多个数据通道
    
    NIO和传统IO之间第一个最大的区别，IO是面向流的，NIO是面向缓冲区的
    
    