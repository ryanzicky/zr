### 创建方式
    1. public myThread extends Thread
    2. public myRunnable implements Runnable
    3. future
    4. callable
    
### 线程同步
    1. Synchroized
        1. 锁的是对象不是代码
        2. this XX.class
        3. 锁定方法 非锁定方法 同时执行
        4. 锁升级
            - 偏向锁 自旋锁 重量级锁
            - 线程数少 - 自旋
            - 线程数多 - 重量级锁
            - 操作消耗时间长 - 重量级锁
    
    2. synchronized(Object)
        - 不能使用String常量 Integer Long
        - "object"
        
### Synchronized
    Synchronized的底层实现
    jdk早期的 重量级 - OS
    后来的改造
    锁升级：
        无锁
        偏向锁
        自旋锁
        重量级锁
        
    sync(object)
    markword 记录这个线程ID (偏向锁)
    如果线程争用：升级为自旋锁
    10 次以后， 升级为重量级锁 - OS
    
    
### 如何选择
    1. 执行时间比较短(加锁代码)，线程比较少，使用自旋锁
    2. 执行时间比较长，线程比较多，使用系统锁
        
### volatile
    JMM内存模型  共享内存
    
    1. 保证线程可见性
        - MESI：缓存一致性协议
            M(Modify)：修改
            E：独占
            S：共享
            I：失效
            
    2. 禁止指令重排序
        - DCL单例
        - Double Check Lock
        - loadrefence原语指令
        - storerefence原语指令
       
     3. 不能保证原子性
     
### AtomicInteger
    AtomicInteger count = new AtomicInteger(0);
    for (int i = 0; i < 10000; i++) {
        count.incrementAndGet();
    }
    无锁操作
    cas

### LongAdder
    LongAdder count = new LongAdder();
    for (int i = 0; i < 10000; i++) {
        count.increment();
    }
    分段锁
    
    分段统计，合并
    fork/join
    
    

### CAS(无锁优化)
    Compare And Set
    cas(V, Expected, NewValue)
    - if V == E
      V = NewValue
      otherwise try again or fail
    - CPU原语支持
        CPU指令级别，中间不能被打断
        
    乐观锁：
    cas(期望值，更新值)
        m = 0
        m ++
        
        expected = read m;
        cas(0, 1) {
            for(;;) 如果当前m值==0; m = 1
        }
        
### Unsafe
    直接操作内存
    直接生成类实例
    直接操作类或实例变量
    CAS相关操作
        - weakCompareAndSwapObject Int Long
    
    compareAndSet
    
    C C++ 指针
    
    C -> malloc free 
    C++ -> new delete

### AQS(CLH)

### ReentrantLock
    可重入锁
    synchronized也是可重入锁
    
    try {
        lock.lock();
    } finally {
        lock.unlock();  // 避免死锁
    }
    
### 多线程之间如何通信
    根据操作系统理论
    多进程之间通讯：
        信号量，信号，套接字，有名管道，无名管道，共享内存，mq
    
    由于多线程之间共享了进程的地址空间，所以，原生就支持数据共享
    当一个线程修改了进程的变量，由于共享空间，另外一个线程自然能看到
    所以原生支持通讯
    
    volatile，sync，ReenTrantLock，ReadWriteReenTrantLock
    
    
    1. 通过共享变量，变量需要volatile修饰
    2. 使用wait()和notify()方法，由于要使用同一把锁，所以必须通知线程释放锁
    被通知线程才能获取到锁，这样导致通知不及时
    3. 使用CountDownLatch实现，通知线程到指定条件，调用CountDownLatch.countDown()，
    被通知线程进行CountDownLatch.await()
    4. 使用Condition的await()方法和singalAll()方法
    
### Synchronized
    作用目标：
        对象
        
    它必须依赖于一个对象存在
    普通实例方法：
        依赖的对象，this，当前类的对象
    静态方法：
        this存在吗，所以推理他肯定不是当前对象
        xxx.class this.getClass -> 由于Synchronized必须依赖于对象
        所以静态方法的依赖对象就是class
    
    静态对象存储在JVM的哪里？
        在Class对象的尾部 -> 在JVM的堆内存中