### 1. 内存模型以及分区，需要详细到每个区放什么
    JVM分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面
    
    class类信息常量池(static常量和static变量)等放在方法区new：
        
    1. 方法区：主要存储类信息，常量池(static常量和static变量)，编译后的代码(字节码)等数据
    2. 堆：初始化的对象，成员变量(那种非static的变量)，所有的对象实例和数组都要
    3. 栈：栈的结构是栈帧组成的，调用一个方法就压入一帧，桢上面存储局部变量表，操作数栈没方法出口等信息，局部变量表存放的是8大基础类型加上一个应用类型，所以还是一个指向地址的指针
    4. 本地方法栈：主要为Native方法服务
    5. 程序计数器：记录当前线程执行行的行号
    
### 2. 堆里的分区：Eden，Survivor(From + To)，老年代，各自的特点
    堆里面分为新生代和老年代(Java8取消了永久代，采用了MateSpace)，新生代包含Eden + Survivoe区，Survivor区分为From和To区，内存回收时，如果采用的是复制算法，从from复制到to，当经过一次或者多次GC之后，存活下来的对象会被移动到老年代，当JVM内存不够用的时候，会触发FULL GC，请求JVM老年代
    当新生代满了之后会触发YGC，先把存活的对象方法一个Survivor区，然后进行垃圾清理，因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把Eden进行完全的清理，然后整理内存，那么下次GC的时候，就是使用下一次Survivor，这样循环使用，如果有特别大的对象，新生代放不下， 就会使用老年代的担保，直接放到老年代里面。因为JVM任务，一般大对象的存活时间一般比较久远
    
### 对象创建方法，对象的内存分配，对象的访问定位
    new一个对象
    
### GC的两种判定方法
    1. 引用计数法：
        指的是如果某个地方引用了这个对象就+1，如果失效了就-1，当为0就会回收但是JVM没有用这种方式，因为无法判定相互循环引用(A引用B，B引用A)的情况
        
    2. 引用链法：
        通过一种GC ROOT的对象(方法区中静态变量引用的对象等static变量)来判断，如果有一条链能够到达GC ROOT就说明不能回收，不能到达就说明可以回收
        
### SafePoint是什么
    比如GC的时候必须要等到Java线程都进入到safepoint的时候VMThread才能开始执行GC，
        1. 循环的末尾(防止大循环的时候一直不进入safepoint，而其他线程等待它进入safepoint)
        
        2. 方法返回前
        3. 调用方法的call之后
        4. 抛出异常的位置
        
### GC的三种收集方法：
    1. 标记清除：
        先标记，标记完毕之后再清除，效率不高，会产生碎片
    2. 标记整理：
        标记完毕之后，让所有存活的对象向一段移动
    3. 复制算法：
        分为8：1的Eden区和Survivor区，就是上面谈到的YGC
        
### GC收集器有哪些？CMS收集器与G1收集器的特点
    1. 并行收集器：
        串行收集器使用一个单独的线程进行收集，GC时服务有停顿时间串行搜集器：次要回收中使用多线程来执行
        
        CMS收集器基于"标记-清除"算法实现的，经过多次标记才会被清除
        
        G1从整体来看是基于"标记-整理"算法实现的收集器，从局部(两个Region之间)上来看是基于"复制"算法实现的
        
### Minor GC与FULL GC分别在什么时候发生
    新生代内存不够用时候发生MGC也叫YGC，JVM内存不够的时候发生FGC
    
### 几种常用的内存调试工具：jmap，jstack，jconsole，jhat jstack
    可以看当前栈的情况，jmap查看内存，jhat进行dump堆的信息mat(eclipse)
    
### 类加载的几个过程
    加载，验证，准备，解析，初始化，然后是使用和卸载
    
    通过全限定名来加载生成class对象到内存中，然后进行验证这个class文件，包括文件格式校验，元数据验证，字节码验证，字节码校验等，准备是对这个对象分配内存，计息是将符号引用转化为直接引用(指针引用)，初始化就是开始执行构造器的代码
    
### JVM内存分哪几个区，每个区的作用是什么
    1. 方法区：
        1. 有时候也称为永久代，在该区很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载
        2. 方法区主要用来存储已被虚拟机加载的类的信息，常量，静态变量和即时编译器编译后的代码等数据
        3. 该区域是被线程共享的
        4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用，该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中
        
    2. 虚拟机栈：
        1. 虚拟机栈也就是我们平常所称的栈内存，它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接和方法出口等信息
        2. 虚拟机栈是线程私有的，它的生命周期与线程相同
        3. 局部变量表里存储的是基本数据类型，returnAddress类型(指向一条字节码指令的地址)和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置，局部变量表所需的内存空间在编译期间确定
        4. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出站的方式
        5.每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接，动态链接就是讲常量池中的符号引用在运行期转化为直接引用
    3. 本地方法栈：
        本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务
    4. 堆：
        java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作
    5. 程序计数器：
        内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理和线程回复等功能都需要依赖这个计数器完成，该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域
        
### 如何判断一个对象是否存活(或者GC对象的判定方法)   
    java中可以作为GC Roots的对象有一下几种：
        1. 虚拟机栈中引用的对象
        2. 方法区静态属性引用的对象
        3. 方法区常量池引用的对象
        4. 本地方法栈JNI引用的对象
        
    当满足上述条件时，一个对象并不一定会被回收，当一个对象不可达GC Roots时，这个对象并不会立马被回收，若要被真正的回收需要经历两次标记
    
    如果对象在可达性分析中没有与GC Roots的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是否有必要执行finalize()方法，当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的
    如果该对象有必要执行finaliz()方法，那么这个对象将会放在一个成为F-Queue的队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃，GC对处于F-Queue中的对象进行第二次被标记，这是，该对象将被移除"即将回收"集合，等待回收
    
### Java垃圾回收机制
    在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行，在JVM中，有一个垃圾回收线程，它是优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那么没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收
    
### Java垃圾收集的方法
    1. 标记-清除：
    2. 复制：
    3. 标记-整理：
    4. 分代收集：
        现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代，在新生代中，由于对象生存周期短，每次回收都会有大量对象死去，那么这是就采用复制算法，老年代里的对象存活效率较高，没有额外的空间进行分配担保，所以可以使用标记-整理或者标记-清除
        
### Java内存模型
    Java内存模型是线程间通信的控制机制，JMM定义了主内存和线程之间抽象关系，线程之间的共享变量存储在主内存中(main memory)，每个线程都有一个私有的本地内存(local memory)，本地内存中存储了该线程以读/写共享变量的副本，本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化，
    
    线程A与线程B之间如要通信的话，必须要经历下面两个步骤：
        1. 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去
        2. 然后，线程B把主内存中去读取A之前已更新过的共享变量
        
### Java类加载过程
    1. 加载：
        1. 通过一个类的全县定名获取该类的二进制流
        2. 将该二进制流中的静态存储结构转化为方法区运行时数据结构
        3. 在内存中生成该类的Class对象，作为该类的数据访问入口
    
    2. 验证：
        验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机，在该阶段主要完成以下四种验证：
            1. 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型
            2. 元数据验证：对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等
            3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据量和控制流的分析，确定程序语义是否正确，主要针对方法体的验证，如：方法中的类型转换是否正确，跳转指令是否正确等
            4. 符号引用验证：这个动作在后面的解析过程中，主要是为了确保解析动作能正确执行
            
    3. 准备：
        准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中
        
        public static int value = 123; // 在准备阶段value初始值为0，在初始化阶段才会变成123
        
    4. 解析：
        该阶段主要完成符号引用到直接引用的转换动作，解析动作并不一定在初始化动作完成之前，也有可能在初始化之后
        
    5. 初始化：
        初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制，到了初始化阶段，才真正开始执行类中定义的java程序代码
        
### Java类加载机制
    虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型
    
### 类加载器双亲委派模型机制
    当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时不能加载，反馈给子类，由子类去完成类的加载
    
### 什么是类加载器，类加载器有哪些
    实现通过类的全限定名获取该类的二进制字节流的代码块叫做类加载器
    主要有一下四种类加载器：
        1. 启动类加载器(Bootstrap ClassLoader)：
        用来加载java核心类库，无法被java程序直接引用
        2. 扩展类加载器(Extensions ClassLoader)：用来加载java的扩展库，JAV阿虚拟机的实现会提供一个类库目录，该类加载器在此目录里面查找并加载java类
        3. 系统类加载器(System ClassLoader)：它根据java应用的类路径(ClassPath)来加载java类，一般来说，Java应用的类都是由它来完成加载的，可以通过ClassLoader.getSystemClassLoader()来获取它
        4. 用户自定义类加载器，通过继承java.lang.ClassLoader类的方式实现
        
### 简述java内存分配与回收率以及Minor GC和Major GC
    1. 对象有限在堆的Eden区分配
    2. 大对象直接进入老年代
    3. 长期存活的对象将直接进入老年代
        当Eden区没有足够的空间进行分配，虚拟机会执行一次Minor GC。Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率高，回收速度比较快，Full GC/Major GC发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度
        
### 新生代(1/3)
       Eden:
           Java新对象的出生地(如果新创建的对象占用内存很大，则直接分配到老年代)，当Eden区内存不够的时候
           就会触发Minor GC，对新生代区进行一次垃圾回收
           
       From Survivor:
            上一次GC的幸存者，作为这一次GC的被扫描者
            
       To Survivor:
            保留了一次Minor GC过程中的幸存者
       Minor GC的过程(复制->清空->互换)
       Minor GC采用复制算法
       1. Eden，SurvivorFrom复制到SurvivorTo，年龄+1
            首先，把Eden和SurvivorFrom区域中存活的对象复制到SurvivorTo区域(如果有对象的年龄已经达到了老年代的标准，则赋值到老年代区)
            同时把这些对象的年龄+1(如果SurvivorTo不够位置了就放到老年代区)
       2. 清空Eden，SurvivorFrom
            然后，清空Eden和SurvivorFrom中的对象
       3. SurvivorFrom和SurvivorTo区域互换
            最后，SurvivorFrom和SurvivirTo区域互换，原SurvivorTo成为下一次GC的SurvivorFrom区    
        
### 老年代(2/3)
    主要存放引用程序中生命周期长的内存对象
    老年代的对象比较稳定，所以MajorGC不会频繁执行，在进行MajorGC钱一般都会进行了一次MinorGC，使得新生代的对象晋升到老年代，
    导致空间不够用时才触发，当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间
    
    MajorGC采用标记清除算法：
        首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收，MajorGC会产生内存碎片。
        为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配，当老年代也满了装不下的时候，会抛出OOM(Out Of Memory)异常
        
### 永久代
    指内存的永久保存区域，主要存放Class和Meta(元数据)的信息，Class在被加载的时候被放入永久区域，它和存放实例的区域不同，GC不会在主程序运行
    期间对永久区域进行清理，所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常
    
### Java8与元空间
    元空间的本质和永久代类似，原空间与永久代之间最大的区别在于，元空间并不存在虚拟机中，而是使用本地内存
    因此，默认情况下，元空间的大小仅受本地内存限值，类的元数据方法Native Memory，字符串池和类的静态变量放入Java堆中，
    这样可以加载多少类的元数据就不再受MaxPermSize控制，而由系统的实际可用空间来控制
    
### 垃圾回收算法
    1. 如何确定垃圾
        1. 引用计数法
        2. 可达性分析
    2. 标记清除算法
        分两个阶段：标记和清除
        最大问题是内存碎片化严重
    3. 复制算法
        内存效率高，不易产生碎片，最大的问题是可用内存被压缩到了原本的一般，且存活对象增多的话，Copying算法的效率会大大降低
    4. 标记整理算法
        标记后不是清理对象，而是将存活对象移向内存的一端，然后清除端边界外的对象
    5. 分代收集算法
        是目前大部分JVM所采用的方法，核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将GC堆划分为老年代和新生代
        老年代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收都有大量垃圾需要被回收，因此可以根据不同区域选择不同
        的算法

### 四种引用类型
    1. 强引用
        把一个对象赋值给一个引用变量，这个引用变量就是一个强引用，当一个对象被强引用变量引用时，它处于可达状态，是不可能被垃圾回收机制回收的，
        强引用对象是造成Java内存泄漏的主要原因之一
        
    2. 软引用
        软引用需要用SoftReference类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它才会被回收，软引用通常
        用在对内存敏感的程序中
      
    3. 弱引用
        弱引用需要用WeakReference类来实现，她比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，
        总会回收该对象占用的内存
       
    4. 虚引用
        虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用，虚引用的主要作用是跟踪对象被垃圾回收的状态
        
### GC垃圾收集器
    1. Serial
        单线程，复制算法
    2. ParNew
        Serial + 多线程
    3. Parallel Scanvenge
        多线程复制算法，高效
    4. Serial Old
        单线程标记整理算法
    5. Parallel Old
        多线程标记整理算法
    6. CMS(Concurrent Mark Sweep)
        多线程标记清除算法，其最主要目标是获取最短垃圾回收停顿时间，和其它老年代使用标记-整理算法不同，它使用多线程的标记-清除算法
        最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验
        1. 初始标记
            标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程
        2. 并发标记
            进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程
        3. 重新标记
            为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程
        4. 并发清除
            清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程，由于耗时最长的并发标记和并发清除过程中，垃圾收集线程
            可以和用户线程一起并发工作，所以整体上来看CMS收集器的内存回收和用户线程是一起并发的执行
    7. G1收集器
        1. 基于标记-整理，不产生内存碎片
        2. 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收
        
        G1收集避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域(Region)，并且跟踪这些区域的垃圾收集进度，同时在后台维护
        一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域，区域划分和优先级区域回收机制，确保G1收集器可以在有限时间
        获得最高的垃圾收集效率
        
### JVM类加载机制
    JVM类加载机制分为五个部分：
        加载，验证，准备，解析，初始化
        
    加载：
        这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口
        
        动态代理
        
    验证：
        确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
        
    准备：
        在方法区中分配这些变量所使用的内存空间
        public static int v = 8080;
        
        实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是
        程序被编译后，存放于类构造器<client>方法之中
        
        public static final int v = 8080;
        在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v
        赋值为 8080
        
    解析：
        解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程，符号引用就是class文件中的
        1. CONSTANT_Class_info
        2. CONSTANT_Field_info
        3. CONSTANT_Method_info
        等类型常量
        
        符号引用：
            引用的目标并不一定要已经加载到内存中，各种虚拟机实现的内存布局可以各不相同
            但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java
            虚拟机规范的Class文件格式中
            
        直接引用：
            直接引用是指向目标的指针，相对便宜量或是一个能间接定位到目标的句柄
            如果有了直接引用，那么引用的目标必定已经在内存中存在
            
    初始化：
        初始化阶段是类加载的最后一个节点，前面的类加载阶段之后，除了在加载阶段可以自定义类
        加载器以外，其他操作都由JVM主导，到了初始阶段，才开始真正执行类中定义的Java的程序代码
        
### 类加载器
    虚拟机设计团队把加载动作放到JVM外部实现，以便让引用程序决定如何获取所需的类。
    JVM提供了三种类加载器：
        1. 启动类加载器(BootStrap ClassLoader)：
            负责加载 JAVA_HOME\lib目录中的，或通过(-Xbootclasspath) 参数指定路径中的，且被虚拟机认可
            (按文件名识别，如rt.jar)的类
            
        2. 扩展类加载器(Extension ClassLoader):
            负责加载 JAVA_HOME\lib\ext目录中的，或通过java.ext.dires系统变量指定路径中的类库
        
        3. 应用程序类加载器(Application ClassLoader)：
            负责加载用户路径(classpath)上的类库：
            JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器
            
### 双亲委派
    当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父
    类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，
    只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的
    Class），子类加载器才会尝试自己去加载。
    
    采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载
    器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载
    器最终得到的都是同样一个 Object 对象
        
### OSGI
    OSGI(Open System Gateway Initiative)：
        是面向Java的动态模型系统，是Java动态化模块化系统的一系列规范

    
      
    
    
    
    
        

    
    
    